<!DOCTYPE html>
<html lang=en>

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Multi-column Tag Editor (with Search)</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background-color: #121212;
            color: #e0e0e0;
        }

        .left,
        .right {
            padding: 10px;
            overflow-y: auto;
        }

        .left {
            width: 40%;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
        }

        .right {
            width: 60%;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .topbar,
        .template-box,
        .footer-controls {
            background-color: #1e1e1e;
            padding: 10px;
            border-radius: 6px;
        }

        .topbar select {
            background-color: #2c2c2c;
            color: #e0e0e0;
            border: 1px solid #555;
            padding: 4px;
        }

        .category-buttons button,
        .template-box button {
            margin: 2px;
            background-color: #2c2c2c;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            padding: 5px 10px;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            background-color: #1e1e1e;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            overflow-y: auto;
            scrollbar-gutter: stable;
        }

        .tag {
            padding: 5px 8px;
            background: #c2c2c2;
            border-radius: 4px;
            cursor: pointer;
        }

        .tag.selected {
            background: #1fce62;
            color: #000;
        }

        .tag-category h3 {
            margin-top: 15px;
            font-size: 18px;
            font-weight: bold;
            color: #ffcc00;
        }

        .tag-subcategory h4 {
            margin: 8px 0 4px;
            font-size: 14px;
            font-weight: bold;
            color: #66ccff;
        }

        .output-box {
            border: 1px solid #555;
            background-color: #1e1e1e;
            padding: 5px;
            position: relative;
        }

        .output-box.selected {
            border: 2px solid #00BCD4;
        }

        .output-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 5px;
        }

        .output-tag {
            background: #4caf50;
            padding: 4px 6px;
            border-radius: 4px;
        }

        .output-tag span {
            margin-left: 4px;
            cursor: pointer;
            color: red;
        }

        .output-box textarea {
            width: 100%;
            height: 60px;
            resize: none;
            background-color: #333;
            color: #eee;
            border: none;
            border-radius: 4px;
            padding: 5px;
            font-size: 14px;
        }


        .output-controls button {
            margin-left: 5px;
        }

.output-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 4px;
}

.move-buttons {
    display: flex;
    gap: 4px;
}


        .template-box span {
            cursor: pointer;
            margin-left: 5px;
            color: red;
        }

        .footer-controls {
            margin-top: auto;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: #1e1e1e;
            border-radius: 6px;
        }

        .footer-controls>div {
            display: flex;
            gap: 10px;
        }

        #templateToggle {
            display: none;
        }

        .group-buttons button.active,
        .category-buttons button.active {
            background-color: #00bcd4;
            color: #000;
            border: 1px solid #00bcd4;
        }

        /* æœå°‹è¼¸å…¥æ¨£å¼ (ä¿å®ˆã€è·Ÿç¾æœ‰ UI ä¸€è‡´) */
        .search-input {
            background-color: #2c2c2c;
            color: #e0e0e0;
            border: 1px solid #555;
            padding: 6px 8px;
            border-radius: 4px;
            margin-left: 8px;
            min-width: 160px;
        }

        .search-wrapper button {
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .search-wrapper button:hover {
            opacity: 1;
        }

        /* === ä¿®æ­£æœå°‹æ¡†æ“ åˆ°ä¸‹ä¸€è¡Œå•é¡Œ === */
        .topbar {
            display: flex;
            align-items: center;
            flex-wrap: nowrap;
            gap: 6px;
            /* æ§åˆ¶èªè¨€é¸å–®èˆ‡æœå°‹æ¬„é–“è· */
        }

        .topbar label,
        .topbar select {
            flex-shrink: 0;
        }

        .topbar .search-wrapper {
            display: flex;
            align-items: center;
            flex: 1;
            /* è®“æœå°‹æ¬„å¯è‡ªå‹•å£“ç¸®è€Œä¸æ›è¡Œ */
            min-width: 0;
            /* é—œéµï¼šå…è¨± flex æ”¶ç¸® */
            position: relative;
        }

        .topbar .search-wrapper input[type="text"] {
            width: 100%;
            min-width: 180px;
            padding-right: 24px;
            /* çµ¦å³å´âœ•ç•™ç©º */
            box-sizing: border-box;
        }

        .topbar .search-wrapper button {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .topbar .search-wrapper button:hover {
            opacity: 1;
        }



        /* æ‰‹æ©Ÿå°ˆç”¨èª¿æ•´ */
        @media (max-width: 768px) {

            body {
                flex-direction: column;
                overflow-x: hidden;
            }

            .group-buttons {
                display: flex;
                flex-wrap: wrap;
                overflow-y: auto;
                line-height: 1.6em;
                max-height: calc(1.6em * 2 + 12px);
                min-height: calc(1.6em * 2 + 12px);
                margin-bottom: 6px;
                flex-shrink: 0;
                background: #1e1e1e;
                border-radius: 6px;
                padding: 6px;
            }

            .category-buttons {
                display: flex;
                flex-wrap: wrap;
                overflow-y: auto;
                line-height: 1.6em;
                max-height: calc(1.6em * 2 + 12px);
                min-height: calc(1.6em * 2 + 12px);
                margin-bottom: 6px;
                flex-shrink: 0;
                background: #1e1e1e;
                border-radius: 6px;
                padding: 6px;
            }

            .group-buttons button,
            .category-buttons button {
                margin: 2px;
                background-color: #2c2c2c;
                color: #e0e0e0;
                border: 1px solid #555;
                border-radius: 4px;
                cursor: pointer;
                height: 32px;
                line-height: 22px;
                padding: 0 8px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
            }

            .left {
                width: 100% !important;
                max-width: 100% !important;
                box-sizing: border-box;
                max-height: 40vh;
                display: flex;
                flex-direction: column;
                flex-shrink: 0;
                min-height: 200px;
            }

            .tag-list {
                display: flex;
                flex-wrap: wrap;
                overflow-y: auto;
                line-height: 1.6em;
                max-height: calc(1.6em * 6.9);
                min-height: calc(1.6em * 6.9);
                flex-shrink: 0;
            }

            #templateToggle.mobile-only {
                display: block;
                background-color: #2c2c2c;
                color: #e0e0e0;
                border: 1px solid #555;
                border-radius: 4px;
                padding: 6px 10px;
                text-align: left;
                height: 38px;
            }

            .template-box {
                display: none;
                position: fixed;
                bottom: 70px;
                left: 5%;
                width: 90%;
                max-height: 60vh;
                overflow-y: auto;
                background: #1e1e1e;
                border: 1px solid #444;
                border-radius: 8px;
                padding: 10px;
                z-index: 1000;
            }

            #undoBtn {
                display: none;
            }

            .template-box.show {
                display: block;
            }

            .right {
                width: 100% !important;
                max-width: 100% !important;
                box-sizing: border-box;
                flex-grow: 1;
                max-height: 43.2vh;
                overflow-y: auto;
                padding-right: 0;
                padding-left: 0;
                padding-bottom: 90px;
            }

            .footer-controls {
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                background: #1e1e1e;
                display: flex;
                flex-direction: column;
                gap: 6px;
                padding: 10px;
                z-index: 999;
            }

            .footer-row1,
            .footer-row2 {
                display: flex;
                align-items: center;
                gap: 8px;
                width: 100%;
                box-sizing: border-box;
                padding: 0 10px;
            }

            #languageSelect,
            #templateToggle.mobile-only {
                width: 80px;
                min-width: 80px;
                max-width: 80px;
                box-sizing: border-box;
            }

            .footer-row1 .right-buttons button,
            .footer-row2 .right-buttons button {
                width: 120px;
                min-width: 120px;
                max-width: 120px;
                text-align: center;
                flex-shrink: 0;
            }

            .footer-row1 .right-buttons button,
            .footer-row2 .right-buttons button {
                flex: 1 1 45%;
                max-width: 120px;
                text-align: center;
            }

            .topbar label[for="languageSelect"] {
                display: none !important;
            }

            .footer-controls #languageSelect {
                -webkit-appearance: none;
                appearance: none;
                background-color: #2c2c2c;
                color: #e0e0e0;
                border: 1px solid #555;
                padding: 6px 8px;
                border-radius: 4px;
                font-size: 14px;
            }

            /* æ‰‹æ©Ÿæ™‚ search input æ”¾åœ¨ groupButtons ä¸Šæ–¹ï¼šç”¨ .mobile-search å€å¡Š */
            .topbar .search-input {
                display: none;
            }

            .mobile-search {
                display: block;
                margin-bottom: 6px;
            }

        }

        /* å·²å„²å­˜çš„æ¨¡æ¿ - æ©«å¼æ’åˆ— */
        #templateList {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        #templateList .template-item {
            flex: 0 0 auto;
            min-width: 150px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: #f9f9f9;
            text-align: center;
            cursor: pointer;
            transition: background 0.2s;
        }

        #templateList .template-item:hover {
            background: #eaeaea;
        }
    </style>
</head>

<body>
    <!-- å·¦é‚Šæ¬„ -->
    <div class="left">
        <div class="topbar">
            <label for="languageSelect">ä»‹é¢èªè¨€:</label>
            <select id="languageSelect">
                <option value=zh>ä¸­æ–‡</option>
                <option value=en>English</option>
                <option value=jp>æ—¥æœ¬èª</option>
            </select>

            <!-- æœå°‹è¼¸å…¥ï¼ˆæ¡Œæ©Ÿ / é è¨­æ”¾åœ¨èªè¨€é¸å–®æ—ï¼‰ -->
            <input id="searchInput" class="search-input" placeholder="æœå°‹ tag æˆ– valueï¼ˆæŒ‰ Enterï¼‰" />

            <!-- ğŸ“‚ æ¨¡æ¿éµè¦æ”¾åœ¨é€™è£¡ï¼Œç·Šè²¼èªè¨€é¸å–®ä¸‹é¢ -->
            <button id="templateToggle" class="mobile-only">ğŸ“‚ æ¨¡æ¿</button>
        </div>

        <!-- æ‰‹æ©Ÿæ™‚ï¼šæŠŠæœå°‹æ”¾åœ¨å¤§é¡ä¸Šæ–¹ï¼ˆé€™å€‹å€å¡Šåªåœ¨æ‰‹æ©Ÿæ™‚é¡¯ç¤ºï¼‰ -->
        <div id="mobileSearchContainer" class="mobile-search" style="display:none;">
            <input id="mobileSearchInput" class="search-input" placeholder="æœå°‹ tag æˆ– valueï¼ˆæŒ‰ Enterï¼‰" />
        </div>

        <!-- æ–°å¢å¤§é¡æŒ‰éˆ•åˆ—ï¼ˆåƒ…æ‰‹æ©Ÿç‰ˆæœƒé¡¯ç¤ºï¼‰ -->
        <div class="group-buttons" id="groupButtons"></div>
        <div class="category-buttons" id="categories"></div>
        <div class="tag-list" id="tagList"></div>


        <div class="template-box">
            <input type="text" id="templateName" placeholder="æ¨¡æ¿åç¨±">
            <button onclick="saveTemplate()">ğŸ’¾ å„²å­˜æ¨¡æ¿</button>
            <button onclick="downloadTemplates()">â¬‡ ä¸‹è¼‰æ¨¡æ¿</button>
            <input type="file" id="uploadInput" onchange="uploadTemplates()" style="margin-top: 6px;">
            <div id="templateList"></div>
        </div>
    </div>

    <!-- å³é‚Šæ¬„ -->
    <div class="right">
        <div id="outputs"></div>
        <div class="footer-controls">
            <div class="left-buttons">
                <button onclick="addOutput()">â• Add Output</button>
                <button onclick="removeLast()">â– Remove Last</button>
            </div>
            <div class="right-buttons">
                <button id="undoBtn" onclick="undoLast()">â†©ï¸</button>
                <button onclick="clearAll()">ğŸ—‘ï¸ Clear All</button>
                <button onclick="copyAll()">ğŸ“‹ Copy All</button>
            </div>
        </div>
    </div>
    <script>

        const rawData = [
            {
                category: { key: "Common words", zh: "å¸¸ç”¨è©", en: "Common words", jp: "ã‚ˆãä½¿ã‚ã‚Œã‚‹å˜èª" },
                groups: [
                    {
                        subCategory: "å¸¸ç”¨",
                        tags: [
                            { zh: "æ±ç”¨æ­£å‘è©", en: "Safe Positive word", jp: "æ±ç”¨ãƒã‚¸ãƒ†ã‚£ãƒ–ãªè¨€è‘‰", value: "nsfw, uncensored,anime style, (masterpiece, best quality, ultra detailed, intricate details, high resolution, smooth lines),concept art, source anime, perfect proportions, perfect_eyes, dynamic pose, lustrous, fair skin, smooth anime skin, soft shading" },
                            { zh: "ä¸€èˆ¬å‘æ­£å‘è©", en: "Safe Positive word", jp: "ä¸€èˆ¬å‘ãƒã‚¸ãƒ†ã‚£ãƒ–ãªè¨€è‘‰", value: "anime style, (masterpiece, best quality, ultra detailed, intricate details, high resolution, smooth lines), concept art, source anime, perfect proportions, perfect_eyes, dynamic pose, lustrous, fair skin, smooth anime skin, soft shading" },
                            { zh: "æ­£å‘è©1", en: "Positive word 1", jp: "ãƒã‚¸ãƒ†ã‚£ãƒ–ãªè¨€è‘‰1", value: "nsfw, uncensored, no censorship, unfiltered, anime style, score_9, score_8_up, masterpiece, best quality, amazing quality, breasts, shiny skin, beautiful face, beautiful eyes, flawless, fair skin, smooth anime skin, soft shading" },
                            { zh: "æ­£å‘è©0", en: "Positive word 0", jp: "ãƒã‚¸ãƒ†ã‚£ãƒ–ãªè¨€è‘‰0", value: "(masterpiece, best quality, ultra detailed, intricate details, high resolution, smooth lines),concept art, source_anime, perfect proportions, perfect_eyes, dynamic pose, lustrous, fair skin, smooth anime skin, soft shading, uncensored" },
                            { zh: "åå‘è©0", en: "Reverse word 0", jp: "é€†å¼•ãå˜èª0", value: "bad anatomy, bad hands, missing fingers, extra fingers, fused fingers, deformed hands, malformed limbs, wrong proportions, extra limbs, mutated hands, poorly drawn hands, malformed body, distorted body, long neck, multiple arms, multiple hands, asymmetrical eyes, deformed face, distorted face, extra nipples, misplaced limbs, deformed legs, malformed feet, glitch, noisy, artifact, blurry, overexposure, oversaturated, flat shading, dull skin, monochrome skin, jpeg artifacts, watermark, signature, text, cropped body, cut off, duplicated body, cloned body" },
                            { zh: "åå‘è©1", en: "Reverse word 1", jp: "é€†å¼•ãå˜èª1", value: "bad quality,worst quality,worst detail,sketch,censor,glowing skin, glowing tattoos, glowing patterns, discolored skin, multicolored skin, green skin, blue skin, purple skin, extra marks, body paint, unrealistic skin, swollen belly, stomach bulge, nipple rings, nipple decorations" },
                            { zh: "åå‘è©2", en: "Reverse word 2", jp: "é€†å¼•ãå˜èª2", value: "bad quality, worst quality, worst detail, lowres, sketch, censor, extra hands, extra fingers, missing fingers, extra digit, fewer digits, deformed hands, wrong proportions, bad anatomy, bad hands, bad feet, mutation, fused limbs, fused fingers, multiple hands, floating hands, disembodied hands, multiple arms, swollen belly, stomach bulge, low quality, normal quality, jpeg artifacts, blurry, text, signature, watermark, username, logos, subtitles, handwriting, lettering, ui elements, error, cropped, glowing skin, overly saturated skin, nipple rings, nipple decorations, black panties, white panties" },
                            { zh: "åå‘è©3", en: "Reverse word 3", jp: "é€†å¼•ãå˜èª3", value: "bad quality, worst quality, low quality, lowres, jpeg artifacts, blurry, sketch, cropped, censor, text, signature, watermark, logo, subtitles, handwriting, ui elements, error,bad anatomy, bad proportions, bad hands, bad feet, deformed hands, malformed limbs, wrong proportions, twisted body, dislocated joints, mutation, mutated limbs, fused fingers, fused limbs,extra hands, extra fingers, extra limbs, multiple limbs, multiple arms, multiple fingers, extra digits, missing fingers, missing limbs, floating hands, disembodied limbs,extra people, additional people, unwanted people, background characters, photobomb, strangers, multiple subjects, crowd,stomach bulge, swollen belly,oversaturated, noisy texture, grainy, low contrast,nsfw censor bars, mosaic, blurry censorship" },
                            { zh: "åå‘è©_æ²’ç”·äºº", en: "Reverse word_no man", jp: "é€†å¼•ãå˜èª_ç”·æ€§ä¸è¦", value: "male, man, men, boy, yaoi, bl, shota, male character, male body, penis, testicles, muscular male, male face, male hands, male legs" },
                            { zh: "åå‘è©_å…¶ä»–äºº", en: "Reverse word_no man", jp: "é€†å¼•ãå˜èª_ä»–è§’ä¸è¦", value: "extra people, background characters, additional subjects, pedestrians, crowd, random person, unwanted person, strangers, multiple characters, photobomb, second person, extra limbs, extra hands" },
                            { zh: "ç„¡ä¿®", en: "uncensored", jp: "ç„¡ä¿®æ­£", value: "nsfw, uncensored,uncensored" },
                            { zh: "è§’è‰²ç”¨", en: "characters", jp: "ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”¨", value: "(Little girl, Loli)" },
                            { zh: "é™°ç”¨", en: "characters2", jp: "ã¾ã‚“ã“ç”¨", value: "secret parts" },
                            { zh: "å¥½èº«æ", en: "good figure", jp: "ãƒŠã‚¤ã‚¹ãƒãƒ‡ã‚£", value: "curvy, voluptuous" },
                            { zh: "R-style", en: "R-style", jp: "R-style", value: "R-style" },
                        ]
                    },
                    {
                        subCategory: "ç•«æ ¼",
                        tags: [
                            { zh: "å–®ç•«é¢æ§‹åœ–ï¼ˆä¸åˆ†æ ¼ï¼‰", en: "single frame composition", jp: "å˜ä¸€æ§‹å›³", value: "single frame" },
                            { zh: "é›™æ ¼åˆ†é¡", en: "two panel composition", jp: "2ã‚³ãƒæ§‹å›³", value: "two panels" },
                            { zh: "ä¸‰æ ¼åˆ†é¡", en: "three panel composition", jp: "3ã‚³ãƒæ§‹å›³", value: "three panels" },
                            { zh: "å·¦å³åˆ†é¡", en: "horizontal panels", jp: "æ¨ªä¸¦ã³ã‚³ãƒ", value: "horizontal panels" },
                            { zh: "ä¸Šä¸‹åˆ†é¡", en: "vertical panels", jp: "ç¸¦ä¸¦ã³ã‚³ãƒ", value: "vertical panels" },
                            { zh: "æ¼«ç•«åˆ†é¡", en: "comic panel layout", jp: "æ¼«ç”»ã‚³ãƒå‰²ã‚Š", value: "comic panels" },
                            { zh: "ç•«æ ¼é‚Šæ¡†", en: "panel borders", jp: "ã‚³ãƒæ ", value: "panel borders" },
                            { zh: "å‹•ä½œé€£çºŒåˆ†é¡", en: "sequential action panels", jp: "é€£ç¶šå‹•ä½œã‚³ãƒ", value: "sequential panels" },
                            { zh: "åŒä¸€è§’è‰²å¤šç•«æ ¼", en: "same character multiple panels", jp: "åŒä¸€ã‚­ãƒ£ãƒ©è¤‡æ•°ã‚³ãƒ", value: "same character panels" },
                            { zh: "æ©«å‘å–®ä¸€æ§‹åœ–ä¸»é«”ç½®ä¸­", en: "centered single composition wide shot", jp: "æ¨ªæ§‹å›³å˜ä¸€æ§‹å›³ä¸­å¤®é…ç½®", value: "centered subject, subject occupies most of the frame, single panel, one shot, one composition, wide angle shot, single focal point" },


                        ]
                    },
                    {
                        subCategory: "16:9 æ©«å‘æ§‹åœ–é˜²é‡è¦†è§’è‰²",
                        tags: [
                            { zh: "å–®ä¸€è§’è‰²æ§‹åœ–", en: "single character composition", jp: "å˜ä¸€ã‚­ãƒ£ãƒ©æ§‹å›³", value: "single character composition" },
                            { zh: "è² ç©ºé–“æ§‹åœ–", en: "negative space composition", jp: "ä½™ç™½æ§‹å›³", value: "negative space composition" },
                            { zh: "ç’°å¢ƒå¡«å……ç•«é¢", en: "environment-focused framing", jp: "èƒŒæ™¯ä¸»å°æ§‹å›³", value: "environment-focused framing" },
                            { zh: "è§’è‰²åç•«é¢ä¸€å´", en: "off-center character placement", jp: "ç‰‡å´é…ç½®", value: "off-center character placement" },
                            { zh: "å»£è§’å ´æ™¯æ§‹åœ–", en: "wide scene composition", jp: "ãƒ¯ã‚¤ãƒ‰æ§‹å›³", value: "wide scene composition" },
                            { zh: "æ™¯æ·±æ‹‰é–‹", en: "deep depth of field", jp: "æ·±ã„è¢«å†™ç•Œæ·±åº¦", value: "deep depth of field" }

                        ]
                    }
                ]
            },
            {
                category: { key: "angle", zh: "è¦–è§’", en: "Angle", jp: "è¦–ç‚¹" },
                groups: [
                    {
                        subCategory: "åŸºæœ¬è§’åº¦",
                        tags: [
                            { zh: "æ­£é¢è¦–è§’", en: "front view", jp: "æ­£é¢ã‹ã‚‰", value: "front view" },
                            { zh: "ä¸Šæ–¹è¦–è§’", en: "from above", jp: "ä¸Šã‹ã‚‰", value: "from above" },
                            { zh: "ä¸‹æ–¹è¦–è§’", en: "from below", jp: "ä¸‹ã‹ã‚‰", value: "from below" },
                            { zh: "å¾Œæ–¹è¦–è§’", en: "from behind", jp: "å¾Œã‚ã‹ã‚‰", value: "from behind" },
                            { zh: "å´é¢è¦–è§’", en: "from side", jp: "æ¨ªã‹ã‚‰", value: "from side" },
                            { zh: "ä½è§’åº¦", en: "low angle", jp: "ãƒ­ãƒ¼ã‚¢ãƒ³ã‚°ãƒ«", value: "pov from below, low angle, from below, cameltoe focus, " },
                            { zh: "å‰æ–¹ä½è§’åº¦", en: "low front angle", jp: "å‰æ–¹ãƒ­ãƒ¼ã‚¢ãƒ³ã‚°ãƒ«", value: "low front angle" },
                            { zh: "å‰æ–¹é«˜è§’åº¦", en: "high front angle", jp: "å‰æ–¹ãƒã‚¤ã‚¢ãƒ³ã‚°ãƒ«", value: "high front angle" },
                            { zh: "èƒŒå¾Œä½è§’åº¦", en: "low back angle", jp: "å¾Œæ–¹ãƒ­ãƒ¼ã‚¢ãƒ³ã‚°ãƒ«", value: "low back angle" },
                            { zh: "èƒŒå¾Œé«˜è§’åº¦", en: "high back angle", jp: "å¾Œæ–¹ãƒã‚¤ã‚¢ãƒ³ã‚°ãƒ«", value: "high back angle" },
                            { zh: "æ–œå´è¦–è§’", en: "oblique side view", jp: "æ–œã‚æ¨ªã‹ã‚‰", value: "oblique side view" },
                            { zh: "å´å¾Œè¦–è§’", en: "side-back view", jp: "æ¨ªå¾Œã‚ã‹ã‚‰", value: "side-back view" },
                            { zh: "å´å‰è¦–è§’", en: "side-front view", jp: "æ¨ªå‰ã‹ã‚‰", value: "side-front view" },
                            { zh: "å‚¾æ–œè¦–è§’", en: "tilted / dutch angle", jp: "å‚¾ãæ§‹å›³", value: "tilted / dutch angle" },
                            { zh: "é€è¦–ç¸®çŸ­", en: "foreshortening", jp: "å°äººè¦–ç‚¹ï¼ˆãƒ‘ãƒ¼ã‚¹ãŒå¼·ããªã‚‹ï¼‰", value: "foreshortening" },
                            { zh: "é³¥ç°è¦–è§’", en: "bird's eye view", jp: "ä¿¯ç°è¦–ç‚¹", value: "bird's eye view" },
                            { zh: "èŸ²ç°è¦–è§’", en: "worm's eye view", jp: "èŸ²ã®è¦–ç‚¹", value: "worm's eye view" },
                        ]
                    },
                    {
                        subCategory: "å‰æ–¹è¦–è§’",
                        tags: [
                            { zh: "æ­£é¢è¦–è§’", en: "front view", jp: "æ­£é¢ã‹ã‚‰", value: "front view, facing viewer" },
                            { zh: "æ­£é¢ä¸Šæ–¹è¦–è§’", en: "front high angle", jp: "å‰æ–¹ãƒã‚¤ã‚¢ãƒ³ã‚°ãƒ«", value: "front high angle, from above" },
                            { zh: "æ­£é¢ä¸‹æ–¹è¦–è§’", en: "front low angle", jp: "å‰æ–¹ãƒ­ãƒ¼ã‚¢ãƒ³ã‚°ãƒ«", value: "front low angle, from below" },
                            { zh: "å·¦å‰è¦–è§’", en: "front-left view", jp: "å·¦å‰ã‹ã‚‰", value: "front-left view" },
                            { zh: "å³å‰è¦–è§’", en: "front-right view", jp: "å³å‰ã‹ã‚‰", value: "front-right view" },
                            { zh: "å·¦å‰ä¸Šæ–¹è¦–è§’", en: "front-left high angle", jp: "å·¦å‰ä¸Šæ–¹ã‹ã‚‰", value: "front-left high angle" },
                            { zh: "å·¦å‰ä¸‹æ–¹è¦–è§’", en: "front-left low angle", jp: "å·¦å‰ä¸‹æ–¹ã‹ã‚‰", value: "front-left low angle" },
                            { zh: "å³å‰ä¸Šæ–¹è¦–è§’", en: "front-right high angle", jp: "å³å‰ä¸Šæ–¹ã‹ã‚‰", value: "front-right high angle" },
                            { zh: "å³å‰ä¸‹æ–¹è¦–è§’", en: "front-right low angle", jp: "å³å‰ä¸‹æ–¹ã‹ã‚‰", value: "front-right low angle" }
                        ]
                    },
                    {
                        subCategory: "å¾Œæ–¹è¦–è§’",
                        tags: [
                            { zh: "èƒŒå¾Œè¦–è§’", en: "back view", jp: "èƒŒé¢ã‹ã‚‰", value: "back view, from behind" },
                            { zh: "èƒŒå¾Œä¸Šæ–¹è¦–è§’", en: "back high angle", jp: "å¾Œæ–¹ãƒã‚¤ã‚¢ãƒ³ã‚°ãƒ«", value: "back high angle, from above" },
                            { zh: "èƒŒå¾Œä¸‹æ–¹è¦–è§’", en: "back low angle", jp: "å¾Œæ–¹ãƒ­ãƒ¼ã‚¢ãƒ³ã‚°ãƒ«", value: "back low angle, from below" },
                            { zh: "å·¦å¾Œè¦–è§’", en: "back-left view", jp: "å·¦å¾Œã‚ã‹ã‚‰", value: "back-left view" },
                            { zh: "å³å¾Œè¦–è§’", en: "back-right view", jp: "å³å¾Œã‚ã‹ã‚‰", value: "back-right view" },
                            { zh: "å·¦å¾Œä¸Šæ–¹è¦–è§’", en: "back-left high angle", jp: "å·¦å¾Œä¸Šæ–¹ã‹ã‚‰", value: "back-left high angle" },
                            { zh: "å·¦å¾Œä¸‹æ–¹è¦–è§’", en: "back-left low angle", jp: "å·¦å¾Œä¸‹æ–¹ã‹ã‚‰", value: "back-left low angle" },
                            { zh: "å³å¾Œä¸Šæ–¹è¦–è§’", en: "back-right high angle", jp: "å³å¾Œä¸Šæ–¹ã‹ã‚‰", value: "back-right high angle" },
                            { zh: "å³å¾Œä¸‹æ–¹è¦–è§’", en: "back-right low angle", jp: "å³å¾Œä¸‹æ–¹ã‹ã‚‰", value: "back-right low angle" }
                        ]
                    },
                    {
                        subCategory: "å´é¢è¦–è§’",
                        tags: [
                            { zh: "å·¦å´è¦–è§’", en: "left side view", jp: "å·¦å´ã‹ã‚‰", value: "left side view" },
                            { zh: "å³å´è¦–è§’", en: "right side view", jp: "å³å´ã‹ã‚‰", value: "right side view" },
                            { zh: "å·¦å´ä¸Šæ–¹è¦–è§’", en: "left high angle", jp: "å·¦ä¸Šæ–¹ã‹ã‚‰", value: "left high angle" },
                            { zh: "å·¦å´ä¸‹æ–¹è¦–è§’", en: "left low angle", jp: "å·¦ä¸‹æ–¹ã‹ã‚‰", value: "left low angle" },
                            { zh: "å³å´ä¸Šæ–¹è¦–è§’", en: "right high angle", jp: "å³ä¸Šæ–¹ã‹ã‚‰", value: "right high angle" },
                            { zh: "å³å´ä¸‹æ–¹è¦–è§’", en: "right low angle", jp: "å³ä¸‹æ–¹ã‹ã‚‰", value: "right low angle" }
                        ]
                    }
                ]
            },
            {
                category: { key: "Pelope", zh: "äººæ•¸", en: "Pelope", jp: "äººæ•°" },
                groups: [
                    {
                        subCategory: " ",
                        tags: [
                            { zh: "å–®äºº", en: "solo", jp: "å˜ä½“", value: "solo" },
                            { zh: "å–®äººå¥³", en: "1girl", jp: "å¥³1äºº", value: "1girl" },
                            { zh: "å–®äººç”·", en: "1man", jp: "ç”·1äºº", value: "1man" },
                            { zh: "é›™äººå¥³", en: "2girls", jp: "å¥³2äºº", value: "2girls" },
                            { zh: "é›™äººç”·", en: "2men", jp: "ç”·2äºº", value: "2men" },
                            { zh: "1 VS 2", en: "duo", jp: "ãƒ‡ãƒ¥ã‚ª", value: "duo" },
                            { zh: "å¤šäºº(ä¹Ÿå¯æŒ‡ç¾¤äº¤å€«O)", en: "group", jp: "ã‚°ãƒ«ãƒ¼ãƒ—", value: "group" },
                            { zh: "å¥³æ€§å¤šæ•¸", en: "many girls", jp: "å¥³å¤šæ•°", value: "many girls" },
                            { zh: "å¤šæ•¸å“¥å¸ƒæ—", en: "many goblins", jp: "ã‚´ãƒ–ãƒªãƒ³å¤šæ•°", value: "many goblins" },
                            { zh: "ç”·æ€§å¤šæ•¸", en: "many men", jp: "ç”·å¤šæ•°", value: "many men" },
                            { zh: "1 VS 3", en: "trio", jp: "ãƒˆãƒªã‚ª", value: "trio" },
                            { zh: "ç”·æœ‰Xäºº", en: "xboy", jp: "ç”·xäººï¼ˆxã‚’æ•°å­—ã«ï¼‰", value: "xboy" },
                            { zh: "å¥³æœ‰Xäºº", en: "xgirl", jp: "å¥³xäººï¼ˆxã‚’æ•°å­—ã«ï¼‰", value: "xgirl" },
                            { zh: "å–®ä¸€è§’è‰²", en: "single character", jp: "å˜ä¸€ã‚­ãƒ£ãƒ©", value: "single character" },
                            { zh: "åªæœ‰ä¸€å€‹äºº", en: "only one person", jp: "ä¸€äººã ã‘", value: "only one person" },
                        ]
                    }
                ]
            }
        ]

        // å¤§é¡è³‡æ–™ï¼Œå°æ‡‰ rawData çš„ category.key
        const groupData = [
            { group: { key: "Common", zh: "å¸¸ç”¨/æ±ç”¨", en: "General", jp: "æ±ç”¨" }, classification: ["Common words", "Pelope", "Hololive", "ren", "copyright", "angle", "color"] },
            { group: { key: "Body", zh: "èº«é«”", en: "Body", jp: "ä½“" }, classification: ["hair color", "Bangs(fringe)", "back of the head hair", "hitomi", "Eyes", "Ear", "Mouth", "body", "brisket", "pussy", "butt", "Physical", "effectï¼ˆbodyï¼‰"] },
            { group: { key: "Clothes", zh: "è¡£æœ", en: "Clothes", jp: "æœ" }, classification: ["pattern", "Innerwear", "upper body clothing(tops)", "bottoms", "full outfit", "swimsuit", "clothes (style)", "sleeves", "ziraike", "head decoration/hat", "clothes", "boots"] },
            { group: { key: "Action", zh: "å‹•ä½œ", en: "Action", jp: "å‹•ä½œ" }, classification: ["poseï¼ˆsampleï¼‰", "poseï¼ˆhandï¼‰", "poseï¼ˆfootï¼‰", "pose", "poseï¼ˆoptionï¼‰", "poseï¼ˆsexï¼‰", "Sex", "Sightline"] },
            { group: { key: "Emotion", zh: "è¡¨æƒ…", en: "Expression", jp: "è¡¨æƒ…" }, classification: ["Emotions_General", "Emotions ï¼ˆHappyï¼‰", "Emotions ï¼ˆSadï¼‰", "Emotions ï¼ˆshyï¼‰", "Emotions ï¼ˆAngerï¼‰", "Emotions ï¼ˆFearï¼‰", "Emotions ï¼ˆOtherï¼‰", "Emotions ï¼ˆmanfuï¼‰", "Emotions ï¼ˆSexï¼‰"] },
            { group: { key: "Environment", zh: "ç’°å¢ƒ", en: "Environment", jp: "ç’°å¢ƒ" }, classification: ["time_weather", "Pleace", "item", "effect", "male", "tentacles", "Ejaculation", "exposure"] },
        ];

        let currentGroupKey = groupData[0].group.key;

        // ğŸ”§ è‡ªå‹•è½‰æ›ç‚º categories èˆ‡ jsonDataï¼ˆç¨‹å¼ç”¨ï¼‰
        const categories = {};
        const jsonData = {};
        rawData.forEach(group => {
            const { key, zh, en, jp } = group.category;
            categories[key] = { zh, en, jp };

            // ğŸ”½ æ‰å¹³åŒ–æ‰€æœ‰å­åˆ†é¡çš„ tags
            const allTags = [];
            if (group.groups) {
                group.groups.forEach(sub => {
                    sub.tags.forEach(tag => {
                        allTags.push({
                            label: { zh: tag.zh, en: tag.en, jp: tag.jp },
                            value: tag.value
                        });
                    });
                });
            }

            jsonData[key] = allTags;
        });

        let currentLang = 'zh';
        let currentCategory = Object.keys(jsonData)[0];
        let currentOutputIndex = 0;
        let outputData = [];
        let templateData = [];
        let undoStack = [];
        const UNDO_LIMIT = 50;

        // DOM refs (will be set on DOMContentLoaded)
        let categoriesDiv = null;
        let tagListDiv = null;
        let outputsDiv = null;
        let languageSelect = null;
        let templateList = null;

        /* -------------------------
           template local storage
        ------------------------- */
        function saveToLocal() {
            localStorage.setItem("aitagTemplates", JSON.stringify(templateData));
        }
        function loadFromLocal() {
            const saved = localStorage.getItem("aitagTemplates");
            if (saved) {
                try {
                    templateData = JSON.parse(saved);
                } catch {
                    templateData = [];
                }
            }
        }

        function downloadTemplates() {
            const checkboxes = document.querySelectorAll(".template-checkbox:checked");
            if (!checkboxes.length) return alert("è«‹å‹¾é¸æ¬²ä¸‹è¼‰çš„æ¨¡æ¿");

            const selected = Array.from(checkboxes).map(cb => templateData[parseInt(cb.dataset.index)]);
            const blob = new Blob([JSON.stringify(selected, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "selected_templates.json";
            a.click();
            URL.revokeObjectURL(url);
        }

        function uploadTemplates() {
            const input = document.getElementById("uploadInput");
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const newTemplates = JSON.parse(e.target.result);
                    if (!Array.isArray(newTemplates)) throw new Error("æ ¼å¼éŒ¯èª¤");
                    newTemplates.forEach(t => {
                        if (t.name && t.data) templateData.push(t);
                    });
                    saveToLocal();
                    renderTemplateList();
                    updateAllTagHighlight();
                } catch {
                    alert("æ¨¡æ¿æ ¼å¼éŒ¯èª¤");
                }
            };
            reader.readAsText(file);
            input.value = "";
        }

        function renderTemplateList() {
            const container = document.getElementById("templateList");
            container.innerHTML = "";
            templateData.forEach((tpl, idx) => {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.className = "template-checkbox";
                checkbox.dataset.index = idx;

                const btn = document.createElement("button");
                btn.textContent = tpl.name;
                btn.onclick = () => {
                    applyTemplate(idx);
                    updateAllTagHighlight();
                };

                const del = document.createElement("span");
                del.textContent = "âœ•";
                del.onclick = () => {
                    templateData.splice(idx, 1);
                    saveToLocal();
                    renderTemplateList();
                };

                const wrapper = document.createElement("div");
                wrapper.appendChild(checkbox);
                wrapper.appendChild(btn);
                wrapper.appendChild(del);
                container.appendChild(wrapper);
            });
        }

        function saveTemplate() {
            const name = document.getElementById("templateName").value.trim();
            if (!name) return alert("è«‹è¼¸å…¥æ¨¡æ¿åç¨±ï¼");
            if (templateData.length >= 30) return alert("æœ€å¤šåªèƒ½å„²å­˜ 30 å€‹æ¨¡æ¿ï¼");
            if (templateData.some(t => t.name === name)) return alert("åç¨±é‡è¤‡ï¼Œè«‹æ›ä¸€å€‹åç¨±");
            const template = {
                name: name,
                data: JSON.parse(JSON.stringify(outputData))
            };
            templateData.push(template);
            saveToLocal();
            renderTemplateList();
            document.getElementById("templateName").value = "";
        }

        function applyTemplate(index) {
            const t = templateData[index];
            if (!t) return;
            outputData = [];
            outputsDiv.innerHTML = "";
            outputData = JSON.parse(JSON.stringify(t.data));
            outputData.forEach((_, i) => createOutputBox(i));
            currentOutputIndex = Math.max(0, outputData.length - 1);
            updateOutputHighlight();
        }

        /* -------------------------
           category / tags rendering
        ------------------------- */
        function renderCategoryButtons() {
            categoriesDiv.innerHTML = '';
            Object.keys(jsonData).forEach((key) => {
                const btn = document.createElement('button');
                btn.textContent = categories[key][currentLang] || key;
                btn.onclick = () => {
                    currentCategory = key;

                    // ğŸ”¹ åµæ¸¬æœå°‹æ¬„æ˜¯å¦æœ‰å…§å®¹
                    const desktopInput = document.getElementById('searchInput');
                    const mobileInput = document.getElementById('mobileSearchInput');
                    const hasSearch =
                        (desktopInput && desktopInput.value.trim()) ||
                        (mobileInput && mobileInput.value.trim());

                    if (hasSearch) {
                        // æ¸…ç©ºæœå°‹æ¬„ä¸¦å›å¾©è©²åˆ†é¡å®Œæ•´ TAG
                        if (desktopInput) desktopInput.value = '';
                        if (mobileInput) mobileInput.value = '';
                        renderTags(key, null);
                    } else {
                        // è‹¥åŸæœ¬å°±æ²’æœ‰æœå°‹æ–‡å­—ï¼Œä¿æŒç¾æœ‰é‚è¼¯
                        const q = (desktopInput || { value: '' }).value.trim();
                        renderTags(key, q || null);
                    }
                };
                categoriesDiv.appendChild(btn);
            });
        }


        // helper to decide match (zh/en/jp/value)
        function tagMatchesFilter(tag, filter) {
            if (!filter) return true;
            const f = String(filter).trim().toLowerCase();
            if (!f) return true;
            return (String(tag.zh || '').toLowerCase().includes(f) ||
                String(tag.en || '').toLowerCase().includes(f) ||
                String(tag.jp || '').toLowerCase().includes(f) ||
                String(tag.value || '').toLowerCase().includes(f));
        }

        // Render a single category (used for no-filter mode)
        function renderCategory(categoryData, filter) {
            const container = document.createElement("div");
            container.className = "tag-category";

            // ä¸»åˆ†é¡æ¨™é¡Œ
            const mainTitle = document.createElement("h3");
            mainTitle.textContent = categoryData.category[currentLang] || categoryData.category.zh || categoryData.category.key;
            container.appendChild(mainTitle);

            // === ğŸ² Category éš¨æ©ŸæŒ‰éˆ• ===
            const catRandom = document.createElement("button");
            catRandom.textContent = "ğŸ²";
            catRandom.style.marginLeft = "8px";
            catRandom.style.padding = "2px 6px";
            catRandom.style.fontSize = "12px";
            catRandom.style.cursor = "pointer";

            catRandom.onclick = (e) => {
                e.stopPropagation();

                // æ”¶é›†æ•´å€‹ category æ‰€æœ‰ tag
                let allTags = [];
                categoryData.groups.forEach(sub => {
                    if (sub.tags && sub.tags.length) {
                        allTags = allTags.concat(sub.tags);
                    }
                });

                if (allTags.length === 0) return;

                // éš¨æ©ŸæŠ½ä¸€å€‹
                const rnd = allTags[Math.floor(Math.random() * allTags.length)];

                // åŠ åˆ°ç•¶å‰ output
                addTagToCurrent(rnd);

                updateOutput(currentOutputIndex);
                updateAllTagHighlight();
            };

            // æ”¾åˆ°æ¨™é¡Œå¾Œé¢
            mainTitle.appendChild(catRandom);


            // å­åˆ†é¡
            categoryData.groups.forEach(group => {
                // æª¢æŸ¥æ­¤å­åˆ†é¡æ˜¯å¦æœ‰ä»»ä½• tag ç¬¦åˆ filter
                const matchedTags = group.tags.filter(t => tagMatchesFilter(t, filter));
                if (matchedTags.length === 0) return; // è‹¥ç„¡ç¬¦åˆï¼Œæ•´å€‹å­åˆ†é¡ä¸é¡¯ç¤º

                const groupDiv = document.createElement("div");
                groupDiv.className = "tag-subcategory";

                const subTitle = document.createElement("h4");
                subTitle.textContent = group.subCategory || '';
                groupDiv.appendChild(subTitle);

                // === ğŸ² éš¨æ©ŸæŒ‰éˆ• ===
                const randomBtn = document.createElement("button");
                randomBtn.textContent = "ğŸ²";
                randomBtn.style.marginLeft = "6px";
                randomBtn.style.padding = "2px 6px";
                randomBtn.style.fontSize = "12px";
                randomBtn.style.cursor = "pointer";

                randomBtn.onclick = (e) => {
                    e.stopPropagation();

                    // å–å‡ºæ­¤ subCategory çš„ tags é™£åˆ—
                    const tags = group.tags;
                    if (!tags || tags.length === 0) return;

                    // éš¨æ©Ÿé¸ä¸€å€‹
                    const rnd = tags[Math.floor(Math.random() * tags.length)];

                    // åŠ é€²ç›®å‰ Output
                    addTagToCurrent(rnd);

                    // æ›´æ–°é¡¯ç¤º & é«˜äº®
                    updateOutput(currentOutputIndex);
                    updateAllTagHighlight();
                };

                subTitle.appendChild(randomBtn);


                // tagsï¼ˆåªæ¸²æŸ“ matchedTagsï¼‰
                matchedTags.forEach(tag => {
                    const btn = document.createElement("button");
                    btn.className = "tag";
                    btn.textContent = tag[currentLang] || tag.en || tag.zh || tag.value;
                    btn.dataset.value = tag.value;

                    //Add weight controls (keeps original behavior)
                    const weight = document.createElement('span');
                    weight.className = 'weight-control';
                    weight.innerHTML = '<button class="wplus">+</button><button class="wminus">-</button>';
                    weight.querySelector('.wplus').onclick = e => {
                        e.stopPropagation();
                        const added = autoAdjustWeight(tag.value, 0.1);
                        if (!added) {
                            const match = tag;
                            match.weight = 1.0;
                            addTagToCurrent(match);
                        }
                        updateAllTagHighlight();
                    };
                    weight.querySelector('.wminus').onclick = e => {
                        e.stopPropagation();
                        autoAdjustWeight(tag.value, -0.1);
                        updateAllTagHighlight();
                    };
                    btn.appendChild(weight);

                    btn.addEventListener("click", () => {
                        toggleTag(btn, tag);
                        updateAllTagHighlight();
                    });

                    groupDiv.appendChild(btn);
                });

                container.appendChild(groupDiv);
            });

            return container;
        }

        /* renderTags:
           - if no filter => render only currentCategory (original behavior)
           - if filter => search across all rawData and display matching categories/groups/tags
        */
        function renderTags(categoryKey, filter) {
            tagListDiv.innerHTML = '';

            // no filter: original behavior - show only current category
            if (!filter) {
                const categoryData = rawData.find(c => c.category.key === categoryKey);
                if (!categoryData) return;
                const categoryEl = renderCategory(categoryData, null);
                tagListDiv.appendChild(categoryEl);
                updateAllTagHighlight();
                return;
            }

            // with filter: search across all categories & groups
            const q = String(filter).trim().toLowerCase();
            const container = document.createElement("div");

            rawData.forEach(categoryData => {
                let categoryHasResults = false;
                const catDiv = document.createElement('div');
                catDiv.className = 'tag-category';

                const title = document.createElement('h3');
                title.textContent = categoryData.category[currentLang] || categoryData.category.zh || categoryData.category.key;

                // build subgroups that match
                categoryData.groups.forEach(group => {
                    const matchedTags = group.tags.filter(t =>
                        (t.zh || '').toLowerCase().includes(q) ||
                        (t.en || '').toLowerCase().includes(q) ||
                        (t.jp || '').toLowerCase().includes(q) ||
                        (t.value || '').toLowerCase().includes(q)
                    );
                    if (!matchedTags.length) return;

                    if (!categoryHasResults) {
                        categoryHasResults = true;
                        catDiv.appendChild(title);
                    }

                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'tag-subcategory';
                    const sub = document.createElement('h4');
                    sub.textContent = group.subCategory || '';
                    groupDiv.appendChild(sub);

                    // === ğŸ² éš¨æ©ŸæŒ‰éˆ• ===
                    const randomBtn = document.createElement("button");
                    randomBtn.textContent = "ğŸ²";
                    randomBtn.style.marginLeft = "6px";
                    randomBtn.style.padding = "2px 6px";
                    randomBtn.style.fontSize = "12px";
                    randomBtn.style.cursor = "pointer";

                    randomBtn.onclick = (e) => {
                        e.stopPropagation();
                        const tags = group.tags;
                        if (!tags || tags.length === 0) return;
                        const rnd = tags[Math.floor(Math.random() * tags.length)];
                        addTagToCurrent(rnd);
                        updateOutput(currentOutputIndex);
                        updateAllTagHighlight();
                    };
                    sub.appendChild(randomBtn);



                    matchedTags.forEach(tag => {
                        const btn = document.createElement('button');
                        btn.className = 'tag';
                        btn.textContent = tag[currentLang] || tag.en || tag.zh || tag.value;
                        btn.dataset.value = tag.value;

                        const weight = document.createElement('span');
                        weight.className = 'weight-control';
                        weight.innerHTML = '<button class="wplus">+</button><button class="wminus">-</button>';
                        weight.querySelector('.wplus').onclick = e => {
                            e.stopPropagation();
                            const added = autoAdjustWeight(tag.value, 0.1);
                            if (!added) {
                                const match = tag;
                                match.weight = 1.0;
                                addTagToCurrent(match);
                            }
                            updateAllTagHighlight();
                        };
                        weight.querySelector('.wminus').onclick = e => {
                            e.stopPropagation();
                            autoAdjustWeight(tag.value, -0.1);
                            updateAllTagHighlight();
                        };
                        btn.appendChild(weight);

                        btn.addEventListener('click', () => {
                            toggleTag(btn, tag);
                            updateAllTagHighlight();
                        });

                        groupDiv.appendChild(btn);
                    });

                    catDiv.appendChild(groupDiv);
                });

                if (categoryHasResults) container.appendChild(catDiv);
            });

            if (!container.children.length) {
                const emptyNote = document.createElement('div');
                emptyNote.style.padding = '10px';
                emptyNote.style.color = '#ccc';
                emptyNote.textContent = `No tags match "${filter}"`;
                tagListDiv.appendChild(emptyNote);
            } else {
                tagListDiv.appendChild(container);
            }

            updateAllTagHighlight();
        }

        /* -------------------------
           output / tag selection logic
        ------------------------- */
        function pushUndoState() {
            undoStack.push(JSON.parse(JSON.stringify(outputData)));
            if (undoStack.length > UNDO_LIMIT) {
                undoStack.shift();
            }
        }

        function undoLast() {
            if (!undoStack.length) return;

            outputData = undoStack.pop();
            outputsDiv.innerHTML = '';

            outputData.forEach((_, i) => createOutputBox(i));

            currentOutputIndex = Math.min(
                currentOutputIndex,
                outputData.length - 1
            );

            updateOutputHighlight();
        }

        function autoAdjustWeight(value, delta) {
            const found = outputData.findIndex(arr => arr.some(t => t.value === value || (typeof t.value === 'string' && t.value.startsWith(`${value}:`))));
            if (found !== -1) {
                currentOutputIndex = found;
                updateOutputHighlight();
                adjustTagWeight(value, delta);
                return true;
            }
            return false;
        }

        function adjustTagWeight(value, delta) {
            pushUndoState();

            const tag = outputData[currentOutputIndex]
                .find(t => t.value === value ||
                    (typeof t.value === 'string' && t.value.startsWith(`${value}:`)));

            if (!tag) return;

            const currentWeight = tag.weight || 1.0;
            const newWeight = Math.max(
                0.1,
                Math.min(2.0, +(currentWeight + delta).toFixed(1))
            );

            tag.weight = newWeight;
            updateOutput(currentOutputIndex);
            updateAllTagHighlight();
        }


        function toggleTag(el, tagObj) {
            const foundIndex = outputData.findIndex(arr =>
                arr.some(t => t.value === tagObj.value)
            );

            // if tag is present in a different output, switch to that output and remove it there
            if (foundIndex !== -1 && foundIndex !== currentOutputIndex) {
                currentOutputIndex = foundIndex;
                updateOutputHighlight();
                removeTag(foundIndex, tagObj.value);
                return;
            }

            const isSelected = el.classList.toggle('selected');
            if (isSelected) {
                addTagToCurrent(tagObj);
            } else {
                removeTag(currentOutputIndex, tagObj.value);
            }
        }

function moveOutput(index, direction) {
    const newIndex = index + direction;

    if (newIndex < 0 || newIndex >= outputData.length) return;

    pushUndoState();

    // äº¤æ›è³‡æ–™
    const temp = outputData[index];
    outputData[index] = outputData[newIndex];
    outputData[newIndex] = temp;

    // æ›´æ–°ç›®å‰é¸ä¸­ index
    currentOutputIndex = newIndex;

    // é‡å»ºæ•´å€‹ UI
    outputsDiv.innerHTML = '';
    outputData.forEach((_, i) => createOutputBox(i));

    updateOutputHighlight();
    updateAllTagHighlight();
}


function createOutputBox(index) {
    const box = document.createElement('div');
    box.className = 'output-box';
    box.onclick = () => {
        currentOutputIndex = index;
        updateOutputHighlight();
    };

    const tagDisplay = document.createElement('div');
    tagDisplay.className = 'output-tags';

    const textarea = document.createElement('textarea');
    textarea.oninput = () => {
        pushUndoState();

        const values = textarea.value
            .split(',')
            .map(t => t.trim())
            .filter(t => t);

        outputData[index] = values.map(v => {
            for (let cat in jsonData) {
                const match = jsonData[cat].find(t => t.value === v);
                if (match) return match;
            }
            return {
                label: { zh: v, en: v, jp: v },
                value: v
            };
        });

        renderTagDisplay(index);
        updateAllTagHighlight();
    };

    const controls = document.createElement('div');
    controls.className = 'output-controls';

    // ğŸ“‹ Copy
    const copyBtn = document.createElement('button');
    copyBtn.textContent = 'ğŸ“‹';
    copyBtn.onclick = (e) => {
        e.stopPropagation();
        navigator.clipboard.writeText(textarea.value);
    };

    // ğŸ—‘ï¸ Clear
    const clearBtn = document.createElement('button');
    clearBtn.textContent = 'ğŸ—‘ï¸';
    clearBtn.onclick = (e) => {
        e.stopPropagation();
        pushUndoState();
        outputData[index] = [];
        updateOutput(index);
        updateAllTagHighlight();
    };

    // â¬†ï¸ ä¸Šç§»
    const upBtn = document.createElement('button');
    upBtn.textContent = 'â¬†ï¸';
    upBtn.onclick = (e) => {
        e.stopPropagation();
        moveOutput(index, -1);
    };

    // â¬‡ï¸ ä¸‹ç§»
    const downBtn = document.createElement('button');
    downBtn.textContent = 'â¬‡ï¸';
    downBtn.onclick = (e) => {
        e.stopPropagation();
        moveOutput(index, 1);
    };

const moveWrap = document.createElement('div');
moveWrap.className = 'move-buttons';
moveWrap.appendChild(upBtn);
moveWrap.appendChild(downBtn);

const leftWrap = document.createElement('div');
leftWrap.appendChild(copyBtn);
leftWrap.appendChild(clearBtn);

controls.appendChild(leftWrap);
controls.appendChild(moveWrap);



    box.appendChild(tagDisplay);
    box.appendChild(textarea);
    box.appendChild(controls);
    outputsDiv.appendChild(box);

    updateOutput(index);
}


        function normalizeValue(v) {
            if (v === null || v === undefined) return '';
            return String(v).trim().replace(/^,+|,+$/g, '').replace(/^[\(\[]+|[\)\]]+$/g, '').toLowerCase();
        }

        function renderTagDisplay(index) {
            const tagContainer = outputsDiv.children[index].querySelector('.output-tags');
            tagContainer.innerHTML = '';

            outputData[index].forEach((tag, i) => {
                const tagValueRaw = (tag && typeof tag === 'object') ? tag.value : tag;
                const normValue = normalizeValue(tagValueRaw);

                let displayText = null;
                let foundTagObj = null;

                outer:
                for (const group of rawData) {
                    if (!group || !group.groups) continue;
                    for (const sub of group.groups) {
                        if (!sub || !Array.isArray(sub.tags)) continue;
                        for (const t of sub.tags) {
                            if (!t) continue;
                            const normT = normalizeValue(t.value);
                            if (normT === normValue) {
                                foundTagObj = t;
                                break outer;
                            }
                        }
                    }
                }

                if (tag && typeof tag === 'object' && tag.label && tag.label[currentLang]) {
                    displayText = tag.label[currentLang];
                } else if (foundTagObj && foundTagObj[currentLang]) {
                    displayText = foundTagObj[currentLang];
                } else if (tagValueRaw != null) {
                    displayText = String(tagValueRaw);
                } else {
                    displayText = '';
                }

                const tagEl = document.createElement('div');
                tagEl.className = 'output-tag';
                const safeValue = String(tagValueRaw).replace(/'/g, "\\'");
                tagEl.innerHTML = `${displayText}<span onclick="removeTag(${index}, '${safeValue}')">âœ•</span>`;
                tagContainer.appendChild(tagEl);
            });
        }

        function removeTag(index, value) {
            pushUndoState();
            outputData[index] = outputData[index].filter(t => t.value !== value);
            updateOutput(index);
            updateAllTagHighlight();
        }


        function updateOutput(index) {
            const text = outputData[index].map(t => {
                if (t.weight && t.weight !== 1.0) {
                    return `(${t.value}:${t.weight}), `;
                }
                return `${t.value}, `;
            }).join('');
            const textarea = outputsDiv.children[index].querySelector('textarea');
            if (textarea) textarea.value = text;
            renderTagDisplay(index);
            updateOutputHighlight();
        }

        function updateOutputHighlight() {
            document.querySelectorAll('.output-box').forEach((el, i) => {
                el.classList.toggle('selected', i === currentOutputIndex);
            });
            updateAllTagHighlight();
        }

        function updateAllTagHighlight() {
            const selected = new Set(outputData.flat().map(t => t.value));
            document.querySelectorAll('.tag').forEach(el => {
                el.classList.toggle('selected', selected.has(el.dataset.value));
            });
        }

        function addTagToCurrent(tagObj) {
            pushUndoState();

            if (!outputData[currentOutputIndex]) {
                outputData[currentOutputIndex] = [];
            }

            const exists = outputData[currentOutputIndex]
                .some(t => t.value === tagObj.value);

            if (!exists) {
                const cleanTag = JSON.parse(JSON.stringify(tagObj));
                delete cleanTag.weight;
                outputData[currentOutputIndex].push(cleanTag);
                updateOutput(currentOutputIndex);
                updateAllTagHighlight();
            }
        }


        function copyAll() {
            const allText = outputData.map(arr =>
                arr.map(t => {
                    if (t.weight && t.weight !== 1) {
                        return `(${t.value}:${t.weight}), `;
                    } else {
                        return `${t.value}, `;
                    }
                }).join('')
            ).join('\nBREAK\n');

            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(allText).catch(err => {
                    console.error("Clipboard API å¤±æ•—:", err);
                });
            } else {
                const textarea = document.createElement("textarea");
                textarea.value = allText;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand("copy");
                document.body.removeChild(textarea);
            }
        }

        function clearAll() {
            pushUndoState();
            for (let i = 0; i < outputData.length; i++) {
                outputData[i] = [];
                updateOutput(i);
            }
            updateAllTagHighlight();
        }


        function addOutput() {
            const newIndex = outputData.length;
            outputData.push([]);
            createOutputBox(newIndex);
        }
        function removeLast() {
            if (outputData.length > 1) {
                outputsDiv.removeChild(outputsDiv.lastChild);
                outputData.pop();
                if (currentOutputIndex >= outputData.length) {
                    currentOutputIndex = outputData.length - 1;
                }
                updateAllTagHighlight();
            }
        }

        /* -------------------------
           responsive footer / language move
        ------------------------- */
        (function () {
            function moveLanguageSelect() {
                const select = document.getElementById('languageSelect');
                const label = document.querySelector('label[for="languageSelect"]');
                const templateToggle = document.getElementById('templateToggle');
                const footerControls = document.querySelector('.footer-controls');
                const topbar = document.querySelector('.topbar');
                const searchInput = document.getElementById('searchInput');
                const mobileSearchContainer = document.getElementById('mobileSearchContainer');
                const mobileSearchInput = document.getElementById('mobileSearchInput');

                if (!select || !footerControls || !templateToggle || !topbar || !searchInput || !mobileSearchContainer) return;

                const origLeft = footerControls.querySelector('.left-buttons');
                const origRight = footerControls.querySelector('.right-buttons');

                if (window.innerWidth <= 768) {
                    if (label) label.style.display = 'none';

                    let row1 = footerControls.querySelector('.footer-row1');
                    let row2 = footerControls.querySelector('.footer-row2');
                    if (!row1) {
                        row1 = document.createElement('div');
                        row1.className = 'footer-row1';
                        footerControls.insertBefore(row1, footerControls.firstChild);
                    }
                    if (!row2) {
                        row2 = document.createElement('div');
                        row2.className = 'footer-row2';
                        footerControls.appendChild(row2);
                    }

                    let row1Right = row1.querySelector('.right-buttons');
                    if (!row1Right) {
                        row1Right = document.createElement('div');
                        row1Right.className = 'right-buttons';
                        row1.appendChild(row1Right);
                    }
                    let row2Right = row2.querySelector('.right-buttons');
                    if (!row2Right) {
                        row2Right = document.createElement('div');
                        row2Right.className = 'right-buttons';
                        row2.appendChild(row2Right);
                    }

                    if (!row1.contains(select)) row1.insertBefore(select, row1.firstChild);

                    if (origLeft) {
                        while (origLeft.firstChild) {
                            row1Right.appendChild(origLeft.firstChild);
                        }
                        origLeft.remove();
                    } else {
                        const btnAdd = footerControls.querySelector('button[onclick*="addOutput"]');
                        const btnRemove = footerControls.querySelector('button[onclick*="removeLast"]');
                        if (btnAdd && !row1Right.contains(btnAdd)) row1Right.appendChild(btnAdd);
                        if (btnRemove && !row1Right.contains(btnRemove)) row1Right.appendChild(btnRemove);
                    }

                    if (!row2.contains(templateToggle)) row2.insertBefore(templateToggle, row2.firstChild);

                    if (origRight) {
                        if (origRight !== row1Right && origRight !== row2Right) {
                            while (origRight.firstChild) {
                                row2Right.appendChild(origRight.firstChild);
                            }
                            origRight.remove();
                        } else {
                            const btnClear = footerControls.querySelector('button[onclick*="clearAll"]');
                            const btnCopy = footerControls.querySelector('button[onclick*="copyAll"]');
                            if (btnClear && !row2Right.contains(btnClear)) row2Right.appendChild(btnClear);
                            if (btnCopy && !row2Right.contains(btnCopy)) row2Right.appendChild(btnCopy);
                        }
                    } else {
                        const btnClear = footerControls.querySelector('button[onclick*="clearAll"]');
                        const btnCopy = footerControls.querySelector('button[onclick*="copyAll"]');
                        if (btnClear && !row2Right.contains(btnClear)) row2Right.appendChild(btnClear);
                        if (btnCopy && !row2Right.contains(btnCopy)) row2Right.appendChild(btnCopy);
                    }

                    // æ‰‹æ©Ÿç‰ˆï¼šæŠŠ searchInput éš±è—ï¼ˆtopbarï¼‰ï¼ŒæŠŠ mobileSearchInput æ”¾åˆ° mobileSearchContainer é¡¯ç¤º
                    searchInput.style.display = 'none';
                    if (!mobileSearchContainer.contains(mobileSearchInput)) mobileSearchContainer.appendChild(mobileSearchInput);
                    mobileSearchContainer.style.display = 'block';

                } else {
                    if (label) label.style.display = '';

                    let newLeft = footerControls.querySelector('.left-buttons');
                    if (!newLeft) {
                        newLeft = document.createElement('div');
                        newLeft.className = 'left-buttons';
                        footerControls.insertBefore(newLeft, footerControls.firstChild);
                    }
                    let newRight = null;
                    footerControls.querySelectorAll(':scope > .right-buttons').forEach(el => newRight = el);
                    if (!newRight) {
                        newRight = document.createElement('div');
                        newRight.className = 'right-buttons';
                        footerControls.appendChild(newRight);
                    }

                    const row1 = footerControls.querySelector('.footer-row1');
                    const row2 = footerControls.querySelector('.footer-row2');

                    if (row1) {
                        const r1Right = row1.querySelector('.right-buttons');
                        if (r1Right) {
                            while (r1Right.firstChild) {
                                newLeft.appendChild(r1Right.firstChild);
                            }
                        }
                        if (!topbar.contains(select)) {
                            if (label && label.parentNode) label.parentNode.insertBefore(select, label.nextSibling);
                            else topbar.appendChild(select);
                        }
                    }

                    if (row2) {
                        const r2Right = row2.querySelector('.right-buttons');
                        if (r2Right) {
                            while (r2Right.firstChild) {
                                newRight.appendChild(r2Right.firstChild);
                            }
                        }
                        if (!topbar.contains(templateToggle)) topbar.appendChild(templateToggle);
                    }

                    if (row1) row1.remove();
                    if (row2) row2.remove();

                    // æ¡Œæ©Ÿç‰ˆï¼šæŠŠ mobileSearchInput é‚„å› topbar çš„ searchInput ä½ç½®
                    mobileSearchContainer.style.display = 'none';
                    if (mobileSearchInput && mobileSearchInput.parentNode) mobileSearchInput.parentNode.removeChild(mobileSearchInput);
                    searchInput.style.display = '';
                }
            }

            window.addEventListener('DOMContentLoaded', moveLanguageSelect);
            window.addEventListener('resize', moveLanguageSelect);
            window.addEventListener('orientationchange', moveLanguageSelect);
        })();

        function renderGroupButtons() {
            const container = document.getElementById("groupButtons");
            if (!container) return;
            container.innerHTML = "";
            groupData.forEach(g => {
                const btn = document.createElement("button");
                btn.textContent = g.group[currentLang] || g.group.key;
                if (g.group.key === currentGroupKey) btn.classList.add("active");
                btn.onclick = () => {
                    currentGroupKey = g.group.key;
                    currentCategory = g.classification[0];
                    renderGroupButtons();
                    renderCategoryButtons_mobile();
                    renderTags(currentCategory);
                };
                container.appendChild(btn);
            });
        }

        function renderCategoryButtons_mobile() {
            categoriesDiv.innerHTML = '';
            const group = groupData.find(g => g.group.key === currentGroupKey);
            if (!group) return;
            group.classification.forEach(key => {
                const category = categories[key];
                if (!category) return;
                const btn = document.createElement('button');
                btn.textContent = category[currentLang] || key;
                if (key === currentCategory) btn.classList.add("active");
                btn.onclick = () => {
                    currentCategory = key;

                    const desktopInput = document.getElementById('searchInput');
                    const mobileInput = document.getElementById('mobileSearchInput');
                    const hasSearch =
                        (desktopInput && desktopInput.value.trim()) ||
                        (mobileInput && mobileInput.value.trim());

                    if (hasSearch) {
                        // æ¸…ç©ºæœå°‹ä¸¦å›å¾©å®Œæ•´åˆ†é¡
                        if (desktopInput) desktopInput.value = '';
                        if (mobileInput) mobileInput.value = '';
                    }

                    renderCategoryButtons_mobile();
                    renderTags(key, null);
                };
                categoriesDiv.appendChild(btn);
            });
        }


        // === ğŸ” å³æ™‚æœå°‹ç³»çµ±ï¼ˆæ¡Œæ©Ÿèˆ‡æ‰‹æ©Ÿå…±ç”¨ï¼‰ ===

        // å»¶é²è§¸ç™¼å‡½å¼ï¼ˆé¿å…è¼¸å…¥æ™‚éåº¦é‡ç¹ªï¼‰
        function debounceSearch(func, delay = 300) {
            let timer = null;
            return (...args) => {
                clearTimeout(timer);
                timer = setTimeout(() => func(...args), delay);
            };
        }

        // === ğŸ” å³æ™‚æœå°‹ + æ¸…é™¤éµç‰ˆæœ¬ ===

        // å»¶é²è§¸ç™¼å‡½å¼ï¼ˆé˜²æ­¢è¼¸å…¥æ™‚éåº¦é‡ç¹ªï¼‰
        function debounceSearch(func, delay = 300) {
            let timer = null;
            return (...args) => {
                clearTimeout(timer);
                timer = setTimeout(() => func(...args), delay);
            };
        }

        // æœå°‹é‚è¼¯ï¼šè¼¸å…¥å³è§¸ç™¼
        const handleSearchSubmit = debounceSearch(() => {
            const desktopInput = document.getElementById('searchInput');
            const mobileInput = document.getElementById('mobileSearchInput');
            const q =
                (desktopInput && desktopInput.value)
                    ? desktopInput.value.trim()
                    : (mobileInput && mobileInput.value ? mobileInput.value.trim() : '');

            renderTags(currentCategory, q || null);
        }, 300);

        // å»ºç«‹ä¸€å€‹å¸¶ã€ŒâŒ æ¸…é™¤ã€æŒ‰éˆ•çš„æœå°‹æ¡†å®¹å™¨
        function wrapSearchInput(input) {
            if (!input || input.dataset.hasWrapper) return;

            const wrapper = document.createElement('div');
            wrapper.className = 'search-wrapper';
            wrapper.style.position = 'relative';
            wrapper.style.display = 'inline-block';
            wrapper.style.width = '100%';

            input.parentNode.insertBefore(wrapper, input);
            wrapper.appendChild(input);

            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'âœ•';
            clearBtn.title = 'æ¸…é™¤æœå°‹';
            clearBtn.style.position = 'absolute';
            clearBtn.style.right = '6px';
            clearBtn.style.top = '50%';
            clearBtn.style.transform = 'translateY(-50%)';
            clearBtn.style.border = 'none';
            clearBtn.style.background = 'transparent';
            clearBtn.style.cursor = 'pointer';
            clearBtn.style.fontSize = '14px';
            clearBtn.style.color = '#666';
            clearBtn.style.display = 'none';
            wrapper.appendChild(clearBtn);

            input.dataset.hasWrapper = 'true';
            input.addEventListener('input', () => {
                clearBtn.style.display = input.value ? 'block' : 'none';
            });

            clearBtn.addEventListener('click', (e) => {
                e.preventDefault();
                input.value = '';
                clearBtn.style.display = 'none';
                handleSearchSubmit();
            });
        }

        // åŒæ­¥æ¡Œæ©Ÿèˆ‡æ‰‹æ©Ÿæœå°‹æ¡† + ç¶å®šå³æ™‚æœå°‹
        function syncSearchInputs() {
            const desktopInput = document.getElementById('searchInput');
            const mobileInput = document.getElementById('mobileSearchInput');
            if (!desktopInput || !mobileInput) return;

            // åŒ…è£å…©å€‹æœå°‹æ¬„ï¼ŒåŠ ä¸Šæ¸…é™¤éµ
            wrapSearchInput(desktopInput);
            wrapSearchInput(mobileInput);

            // åŒæ­¥å…©é‚Šçš„è¼¸å…¥
            desktopInput.addEventListener('input', () => {
                mobileInput.value = desktopInput.value;
                handleSearchSubmit();
            });
            mobileInput.addEventListener('input', () => {
                desktopInput.value = mobileInput.value;
                handleSearchSubmit();
            });

            // æ”¯æ´ ESC éµæ¸…é™¤æœå°‹
            const clearBoth = () => {
                desktopInput.value = '';
                mobileInput.value = '';
                handleSearchSubmit();
            };
            desktopInput.addEventListener('keydown', (e) => { if (e.key === 'Escape') clearBoth(); });
            mobileInput.addEventListener('keydown', (e) => { if (e.key === 'Escape') clearBoth(); });
        }


        // ä¿®å¾©æ‰‹æ©Ÿæ¨¡æ¿éµè¡Œç‚ºï¼ˆè¢«ç§»å‹•åˆ° footer æ™‚ä¹Ÿèƒ½ä½œç”¨ï¼‰
        function bindTemplateToggle() {
            const toggle = document.getElementById('templateToggle');
            const templateBox = document.querySelector('.template-box');
            if (!toggle || !templateBox) return;
            toggle.addEventListener('click', (e) => {
                e.stopPropagation();
                templateBox.classList.toggle('show');
            });
            document.addEventListener('click', (ev) => {
                if (!templateBox.classList.contains('show')) return;
                if (ev.target === toggle || templateBox.contains(ev.target)) return;
                templateBox.classList.remove('show');
            });
        }

        // åˆå§‹åŒ–
        document.addEventListener("DOMContentLoaded", () => {
            categoriesDiv = document.getElementById('categories');
            tagListDiv = document.getElementById('tagList');
            outputsDiv = document.getElementById('outputs');
            languageSelect = document.getElementById('languageSelect');
            templateList = document.getElementById('templateList');

            loadFromLocal();
            syncSearchInputs();
            bindTemplateToggle();

            if (window.innerWidth <= 768) {
                renderGroupButtons();
                renderCategoryButtons_mobile();
                renderTags(currentCategory);
            } else {
                renderCategoryButtons();
                renderTags(currentCategory);
            }

            // å»ºç«‹ä¸‰å€‹è¼¸å‡ºæ¡†
            for (let i = 0; i < 3; i++) {
                outputData.push([]);
                createOutputBox(i);
            }
            renderTemplateList();

            languageSelect.onchange = () => {
                currentLang = languageSelect.value;
                if (window.innerWidth <= 768) {
                    renderGroupButtons();
                    renderCategoryButtons_mobile();
                    renderTags(currentCategory);
                } else {
                    renderCategoryButtons();
                    renderTags(currentCategory);
                }
                outputData.forEach((_, i) => renderTagDisplay(i));
                updateOutputHighlight();
            };
        });
    </script>
</body>

</html>